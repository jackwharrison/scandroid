<!DOCTYPE html>
<html lang="{{ lang }}" {% if lang == 'ar' %}dir="rtl"{% endif %}>
<head>
  <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='favicon.ico') }}">
  <meta charset="UTF-8">
  <title>FSP Admin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

  <style>
    :root {
      --bg: #f3f4f6;
      --card: #ffffff;
      --ink: #111827;
      --muted: #6b7280;
      --line: #e5e7eb;
      --radius: 16px;
      --shadow-soft: 0 10px 30px rgba(0,0,0,0.06);
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background-color: var(--bg);
      color: var(--ink);
      margin: 0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    header {
      background-color: #ffffff;
      padding: 16px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }

    .header-left {
      display:flex;
      align-items:center;
      gap:12px;
    }

    .header-left img {
      height: 50px;
      object-fit: contain;
    }

    .scandroid-banner {
      flex: 1;
      text-align: center;
    }

    .scandroid-banner img {
      height: 80px;
      max-width: 60%;
      object-fit: contain;
      display: inline-block;
    }

    .right-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .right-controls select {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      background: #ffffff;
      font-weight: 600;
      cursor: pointer;
    }

    .logout-button {
      padding: 8px 14px;
      background-color: #dc3545;
      color: #ffffff;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
    }

    .logout-button:hover {
      background-color: #b91c1c;
    }

    .status-pill {
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:4px 10px;
      border-radius:999px;
      font-size:12px;
      font-weight:700;
      border:1px solid transparent;
    }
    .status-pill.online {
      background:#e7f9ef; color:#0f5132; border-color:#b7ebcd;
    }
    .status-pill.offline {
      background:#fdecec; color:#842029; border-color:#f5c2c7;
    }

    main {
      flex-grow: 1;
      padding: 24px 16px 40px 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
    }

    .row-box {
      max-width: 520px;
      width: 100%;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .info-box {
      flex: 1;
      background: #ffffff;
      border-radius: 12px;
      padding: 12px 16px;
      box-shadow: var(--shadow-soft);
      border: 1px solid var(--line);
      font-size: 0.95rem;
    }

    .info-title {
      font-weight: 700;
      color: var(--ink);
      margin-bottom: 4px;
    }

    .info-sub {
      color: var(--muted);
      font-size: 0.9rem;
    }

    #syncBtn, #scanBtn, #sendBtn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 12px 20px;
      font-size: 1rem;
      font-weight: 700;
      border: none;
      border-radius: 14px;
      cursor: pointer;
      white-space: nowrap;
      box-shadow: var(--shadow-soft);
      transition: transform 0.05s ease, box-shadow 0.1s ease, background-color 0.1s ease;
    }

    #syncBtn {
      background-color: #1d4ed8;
      color: #fff;
    }
    #syncBtn:hover:not(:disabled) { background:#1e40af; transform:translateY(-1px); }

    #scanBtn {
      background-color:#16a34a;
      color:white;
    }
    #scanBtn:hover { background:#15803d; transform:translateY(-1px); }

    #sendBtn {
      background-color:#be185d;
      color:white;
    }
    #sendBtn:hover { background:#9d174d; transform:translateY(-1px); }

    footer {
      display: flex;
      justify-content: space-between;
      padding: 12px 18px 16px 18px;
      font-size: 0.9rem;
      background-color: #f9fafb;
      border-top: 1px solid #e5e7eb;
      flex-wrap: wrap;
    }
    #syncBtn img,
    #scanBtn img,
    #sendBtn img {
      height: 20px;
      filter: invert(1);
    }
    /* --- Spinner animation --- */
    .spinner {
      width: 18px;
      height: 18px;
      border: 3px solid rgba(255,255,255,0.6);
      border-top-color: white;
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Button loading state */
    .btn-loading {
      opacity: 0.8;
      pointer-events: none;
      transform: none !important;
    }

    .btn-loading img {
      opacity: 0.3; /* keep SVG but fade slightly */
    }



  </style>
</head>

<body>

<header>
  <div class="header-left">
    <img src="{{ url_for('static', filename='ns1.png') }}" alt="NS1">
    <img src="{{ url_for('static', filename='ns2.png') }}" alt="NS2">
  </div>

  <div class="scandroid-banner">
    <img src="{{ url_for('static', filename='scandroid_banner.png') }}" alt="Scandroid">
  </div>

  <div class="right-controls">
    <span id="netStatus" class="status-pill offline">{{ t.offline or "Offline" }}</span>

    <form method="get" action="/fsp-admin">
      <select name="lang" onchange="this.form.submit()">
        <option value="en" {% if lang=='en' %}selected{% endif %}>English</option>
        <option value="fr" {% if lang=='fr' %}selected{% endif %}>Fran√ßais</option>
        <option value="ar" {% if lang=='ar' %}selected{% endif %}>ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
      </select>
    </form>

    <form method="get" action="/fsp-logout">
      <button type="submit" class="logout-button">{{ t.logout or "Logout" }}</button>
    </form>
  </div>
</header>

<main>

  <!-- SYNC BLOCK -->
  <div class="row-box">
    <div class="info-box">
      <div class="info-title">
        {{ t.beneficiaries_ready_to_scan or "Ready to scan:" }}
        <span id="beneficiaryCount">0</span>
      </div>
      <div class="info-sub">
        {{ t.last_synced or "Last synced:" }}
        <span id="lastSyncedText">Not synced yet</span>
      </div>
    </div>

    <button id="syncBtn">
      <img src="{{ url_for('static', filename='icons/sync.svg') }}" alt="" style="height:20px;">
      Sync
    </button>
  </div>

  <!-- SCAN BLOCK -->
  <div class="row-box">
    <div class="info-box">
      <div class="info-title">
        {{ t.people_scanned or "People scanned:" }}
        <span id="peopleScannedCount">0</span>
      </div>
      <div class="info-sub">
        {{ t.total_amount or "Total amount:" }}
        <span id="totalAmountText">‚Äî</span>
      </div>
    </div>

    <button id="scanBtn" onclick="location.href='/scan?lang={{ lang }}'">
      <img src="{{ url_for('static', filename='icons/scan.svg') }}" alt="" style="height:20px;">
      Scan
    </button>
  </div>

  <!-- SEND BLOCK -->
  <div class="row-box">
    <div class="info-box">
      <div class="info-title">
        {{ t.payments_ready_send or "Payments ready to send:" }}
        <span id="paymentsReadyCount">0</span>
      </div>

      <div class="info-sub">
        {{ t.last_payments_submit or "Last submission:" }}
        <span id="lastSubmissionText">‚Äî</span>
      </div>

      <div id="sendError" class="error-box" style="display:none;"></div>
    </div>

    <button id="sendBtn">
      <img src="{{ url_for('static', filename='icons/send.svg') }}" alt="" style="height:20px;">
      Send
    </button>
  </div>

</main>

<footer>
  <div class="footer-left">{{ t.footer_dev }}</div>
  <div class="footer-right">{{ t.footer_support }}</div>
</footer>

<script>
  // JINJA TEMPLATE VARIABLE
  const t = {{ t | tojson | safe }};
</script>

<script>
  const PROGRAM_CURRENCY = "{{ config.get('programCurrency', '') }}";
</script>


<!-- IndexedDB helper -->
<script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
<!-- ZIP helper -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script>
  const COLUMN_TO_MATCH = "{{ COLUMN_TO_MATCH }}";
</script>

<script>
  const ONLINE_TEXT = "{{ t.online or 'Online' }}";
  const OFFLINE_TEXT = "{{ t.offline or 'Offline' }}";

  // -----------------------------
  // UPDATED SYNC BUTTON HANDLER
  // -----------------------------
  document.getElementById("syncBtn").addEventListener("click", async function () {
    if (!navigator.onLine) return;

    const btn = this;
    const statusDiv = document.getElementById("statusMessage");

    // Store original button content (SVG + text)
    const originalHTML = btn.innerHTML;

    // Visual loading state
    btn.classList.add("btn-loading");
    btn.disabled = true;

    btn.innerHTML = `
      ${originalHTML}
      <div class="spinner" style="margin-left:6px;"></div>
    `;

    try {
      const syncRes = await fetch("/sync-fsp?lang={{ lang }}");
      const syncJson = await syncRes.json();
      const syncMessage = syncJson.message || "Synced";

      statusDiv && (statusDiv.textContent = syncMessage + " ‚Üí Importing‚Ä¶");

      const importResult = await importLatestCache(true);

      const finalMessage =
        `Sync complete: ${syncMessage} ‚Üí Imported ${importResult.written} beneficiaries and ${importResult.photosWritten} photos.`;

      statusDiv && (statusDiv.textContent = "‚úÖ " + finalMessage);

      // Timestamp
      const now = new Date();
      const formatted = now.toLocaleString("en-GB", {
        day: "2-digit",
        month: "2-digit",
        year: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });

      const lastSyncedEl = document.getElementById("lastSyncedText");
      const readyCountEl = document.getElementById("beneficiaryCount");

      if (lastSyncedEl) lastSyncedEl.textContent = formatted;
      if (readyCountEl) readyCountEl.textContent = importResult.written;

      localStorage.setItem("scandroid_last_synced_date", formatted);
      localStorage.setItem("scandroid_last_synced_count", importResult.written);

    } catch (err) {
      console.error(err);
      statusDiv && (statusDiv.textContent = "‚ùå Failed to sync & import. Please try again.");
    }

    // Restore original button content
    btn.innerHTML = originalHTML;
    btn.classList.remove("btn-loading");
    btn.disabled = false;
  });

  // Service worker
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/service-worker.js?v=2', { updateViaCache: 'none' }).catch(()=>{});
    });
  }

  // Online detection -> update status pill
  const pill = document.getElementById('netStatus');
  function setOnlineState(isOnline) {
    pill.textContent = isOnline ? ONLINE_TEXT : OFFLINE_TEXT;
    pill.classList.toggle('online', isOnline);
    pill.classList.toggle('offline', !isOnline);
  }

  async function pingWithTimeout(timeoutMs = 2000) {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeoutMs);
    try {
      const res = await fetch('/ping', { cache: 'no-store', signal: controller.signal });
      clearTimeout(timer);
      return res.ok;
    } catch {
      clearTimeout(timer);
      return false;
    }
  }

  async function checkOnline() {
    const ok = await pingWithTimeout(2000);
    setOnlineState(ok);
  }

  checkOnline();
  setInterval(checkOnline, 30000);
  window.addEventListener('online', () => setOnlineState(true));
  window.addEventListener('offline', () => setOnlineState(false));
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistration().then(reg => reg && reg.update());
  }
</script>

<script>
  // ---------- IndexedDB ----------
  async function openScandroidDB() {
    return await idb.openDB('scandroid', 13, {
      upgrade(db) {
        if (!db.objectStoreNames.contains('records')) db.createObjectStore('records', { keyPath: 'uuid' });
        if (!db.objectStoreNames.contains('photos'))  db.createObjectStore('photos',  { keyPath: 'uuid' });
        if (!db.objectStoreNames.contains('meta'))    db.createObjectStore('meta',    { keyPath: 'key' });
        if (!db.objectStoreNames.contains('decisions')) db.createObjectStore('decisions', { keyPath: 'uuid' });
        if (!db.objectStoreNames.contains('transaction')) db.createObjectStore('transaction', { keyPath: 'uuid' });
        if (!db.objectStoreNames.contains('payments')) db.createObjectStore('payments', { keyPath: 'uuid' });
      }
    });
  }

  const chunk = (arr, size) =>
    Array.from({ length: Math.ceil(arr.length / size) }, (_, i) => arr.slice(i * size, i * size + size
)) ;

  const findJsonEntry = (zip) =>
    Object.values(zip.files).find(f => /registrations_cache\.json$/i.test(f.name)) || null;

  const listPhotoEntries = (zip) =>
    Object.values(zip.files).filter(f => /\.enc$/i.test(f.name));

  // -----------------------------------------------------
  // UPDATED importLatestCache() SUPPORTS SILENT MODE + RETURNS COUNTS
  // -----------------------------------------------------
  async function importLatestCache(silent = false) {
    if (!navigator.onLine) {
      if (!silent) showOfflineWarningTemporarily();
      return { written: 0, photosWritten: 0 };
    }

    const statusDiv = document.getElementById('statusMessage');

    try {
      const res = await fetch('/api/offline/latest.zip', { cache: 'no-store' });
      if (!res.ok) throw new Error(`Fetch latest.zip failed: ${res.status}`);
      const zipBlob = await res.blob();
      const zip = await JSZip.loadAsync(zipBlob);

      const jsonEntry = findJsonEntry(zip);
      if (!jsonEntry) throw new Error('registrations_cache.json not found in ZIP');
      const jsonText = await jsonEntry.async('string');
      const records = JSON.parse(jsonText) || [];

      const db = await openScandroidDB();

      // Import records
      let written = 0;
      for (const group of chunk(records, 50)) {
        await Promise.all(group.map(async rec => {
          const uuid = rec.uuid || rec._uuid;
          if (!uuid) return;
          await db.put('records', rec);
          written++;
        }));
      }

      // Import photos
      const photos = listPhotoEntries(zip);
      let photosWritten = 0;
      for (const group of chunk(photos, 10)) {
        const items = await Promise.all(group.map(async entry => {
          const m = entry.name.match(/([^/\\]+)\.enc$/i);
          const uuid = m ? m[1] : null;
          if (!uuid) return null;
          const buf = await entry.async('arraybuffer');
          return { uuid, bytes: new Uint8Array(buf) };
        }));
        await Promise.all(items.filter(Boolean).map(item => db.put('photos', item)));
        photosWritten += items.filter(Boolean).length;
      }

      // ---- NEW: import transactions.json ----
      const txEntry = Object.values(zip.files).find(f => /transactions\.json$/i.test(f.name));
      if (txEntry) {
        const txText = await txEntry.async("string");
        const txList = JSON.parse(txText) || [];

        for (const t of txList) {
          const uuid = t.registrationReferenceId || t.uuid;
          if (!uuid) continue;

          await db.put("transaction", {
            uuid: uuid,
            amount: t.amount || 0,
            paymentId: t.paymentId
          });
        }
      }

      if (!silent) {
        statusDiv.textContent =
          `‚úÖ ${written} beneficiaries ¬∑ ${photosWritten} photos imported.`;
      }

      await db.put('meta', {
        key: 'batchInfo',
        value: { importedAt: Date.now(), recordCount: written, photos: photosWritten }
      });

      // RETURN COUNTS
      return { written, photosWritten };

    } catch (err) {
      console.error(err);
      if (!silent) {
        statusDiv.textContent = `‚ùå Import failed: ${err.message || err}`;
      }
      return { written: 0, photosWritten: 0 };
    }
  }
</script>

<script>

  const generateCsvBtn = document.getElementById('generateCsvBtn');
  const submitCsvBtn = document.getElementById('submitCsvBtn');
  const csvCountEl = document.getElementById('csv-count');
  const submitStatus = document.getElementById('submit-status');
  let cachedCsvBlob = null;

  async function loadPaymentsAndCount() {
    const db = await openScandroidDB();
    if (!db.objectStoreNames.contains('payments')) return 0;

    const tx = db.transaction('payments', 'readonly');
    const store = tx.objectStore('payments');
    const allPayments = await store.getAll();
    csvCountEl.textContent = allPayments.length;
    return allPayments;
  }

  // Decrypt helper
  async function decrypt(encrypted, keyHex) {
    try {
      const key = await crypto.subtle.importKey(
        "raw",
        hexToBytes(keyHex),
        "AES-GCM",
        false,
        ["decrypt"]
      );

      const data = atob(encrypted);
      const iv = Uint8Array.from(data.slice(0, 12), c => c.charCodeAt(0));
      const ciphertext = Uint8Array.from(data.slice(12), c => c.charCodeAt(0));
      const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ciphertext);
      return new TextDecoder().decode(decrypted);
    } catch (err) {
      console.error("Decryption failed:", err);
      return encrypted;
    }
  }

  function hexToBytes(hex) {
    return new Uint8Array(hex.match(/.{1,2}/g).map(b => parseInt(b, 16)));
  }

  generateCsvBtn.addEventListener('click', async () => {
    generateCsvBtn.disabled = true;
    submitStatus.textContent = "‚è≥ Generating CSV...";

    const db = await openScandroidDB();
    const payments = await loadPaymentsAndCount();

    if (!payments.length) {
      submitStatus.textContent = "‚ö†Ô∏è No payments to export.";
      generateCsvBtn.disabled = false;
      return;
    }

    const metaTx = db.transaction('meta', 'readonly');
    const metaStore = metaTx.objectStore('meta');
    const encKeyObj = await metaStore.get('encryptionKey');
    const encKey = encKeyObj?.value || '';

    const csvRows = [['phoneNumber', 'status']];
    for (const p of payments) {
      let phone = p.match_value;
      if (encKey && phone && phone.startsWith('gAAAA')) {
        phone = await decrypt(phone, encKey);
      }
      csvRows.push([phone, p.status]);
    }

    const csvContent = csvRows.map(row => row.join(',')).join('\n');
    cachedCsvBlob = new Blob([csvContent], { type: 'text/csv' });

    submitStatus.textContent = "‚úÖ CSV ready with " + (csvRows.length - 1) + " records.";
    submitCsvBtn.disabled = false;
  });

  submitCsvBtn.addEventListener('click', async () => {
    if (!navigator.onLine) {
      return;
    }
    if (!cachedCsvBlob) {
      alert("No CSV generated yet.");
      return;
    }

    const formData = new FormData();
    formData.append('csv', cachedCsvBlob, 'payments.csv');

    submitStatus.textContent = "üì§ Sending...";
    try {
      const res = await fetch('/submit-payments', {
        method: 'POST',
        body: formData
      });

      const responseText = await res.text();
      if (!res.ok) throw new Error(responseText || "Unknown error from server");

      submitStatus.textContent =
        t.payment_submit_success || "‚úÖ Payments submitted successfully!";

      const db = await openScandroidDB();
      const tx = db.transaction('payments', 'readwrite');
      await tx.objectStore('payments').clear();

      csvCountEl.textContent = "0";
      submitCsvBtn.disabled = true;
      generateCsvBtn.disabled = false;
      cachedCsvBlob = null;
    } catch (err) {
      console.error(err);
      submitStatus.textContent =
        (t.payment_submit_failed || "‚ùå Failed to submit") + ": " + (err.message || "Unknown error");
    }
  });

  // Init on page load
  loadPaymentsAndCount();

  let popupTimeout;
  function closeOfflinePopup() {
    const popup = document.getElementById('offline-popup');
    popup.style.display = 'none';
    clearTimeout(popupTimeout);
  }

  // Load last synced time from localStorage on page load
  // Load "Last synced" summary on page load


</script>

<script>
  async function loadPeopleScannedCount() {
    try {
      const db = await openScandroidDB();

      if (!db.objectStoreNames.contains("payments")) {
        document.getElementById("peopleScannedCount").textContent = "0";
        return;
      }

      const tx = db.transaction("payments", "readonly");
      const store = tx.objectStore("payments");
      const all = await store.getAll();

      // Count ONLY pending, not submitted
      const count = all.filter(p => p.status === "success").length;

      document.getElementById("peopleScannedCount").textContent = count;

    } catch (err) {
      console.error("peopleScannedCount error:", err);
      document.getElementById("peopleScannedCount").textContent = "0";
    }
  }


  // ‚úÖ RUN ON PAGE LOAD
  window.addEventListener("DOMContentLoaded", loadPeopleScannedCount);
</script>

<script>
async function loadTotalAmount() {
  try {
    const db = await openScandroidDB();

    if (!db.objectStoreNames.contains("transaction") ||
        !db.objectStoreNames.contains("payments")) {
      document.getElementById("totalAmountText").textContent = "0";
      return;
    }

    // 1. Load only "success" (pending) scanned beneficiaries
    const payTx = db.transaction("payments", "readonly");
    const payStore = payTx.objectStore("payments");
    const allPayments = await payStore.getAll();
    const pending = allPayments.filter(p => p.status === "success");

    const scannedSet = new Set(pending.map(x => x.uuid));

    // 2. Load all transactions
    const tx = db.transaction("transaction", "readonly");
    const store = tx.objectStore("transaction");
    const transactions = await store.getAll();

    // 3. Sum ONLY amounts of beneficiaries that are still pending
    let total = 0;
    for (const t of transactions) {
      if (scannedSet.has(t.uuid)) {
        total += t.amount || 0;
      }
    }

    document.getElementById("totalAmountText").textContent =
      PROGRAM_CURRENCY
        ? total.toLocaleString() + " " + PROGRAM_CURRENCY
        : total.toLocaleString();

  } catch (e) {
    console.error("Total amount calc error:", e);
    document.getElementById("totalAmountText").textContent = "0";
  }
}

window.addEventListener("DOMContentLoaded", loadTotalAmount);

</script>

<!-- *** NEW SEND LOGIC ‚Äì Added NON-DESTRUCTIVELY *** -->
<script>
async function loadPaymentsReadyCount() {
  const db = await openScandroidDB();
  if (!db.objectStoreNames.contains("payments")) {
    document.getElementById("paymentsReadyCount").textContent = "0";
    return [];
  }
  const tx = db.transaction("payments", "readonly");
  const store = tx.objectStore("payments");
  const all = await store.getAll();
  const pending = all.filter(p => p.status === "success");

  document.getElementById("paymentsReadyCount").textContent = pending.length;
  return pending;

}

function loadLastSubmission() {
  const saved = localStorage.getItem("scandroid_last_payment_submission");
  if (saved) document.getElementById("lastSubmissionText").textContent = saved;
}

async function buildCsvFromPayments(payments) {
  const db = await openScandroidDB();
  const metaTx = db.transaction("meta", "readonly");
  const metaStore = metaTx.objectStore("meta");
  const encKeyObj = await metaStore.get("encryptionKey");
  const encKey = encKeyObj?.value || "";

  // üî• Use the correct match column name from config
  const rows = [[COLUMN_TO_MATCH, "status"]];

  for (const p of payments) {
    let matchValue = p.match_value;

    if (encKey && matchValue && matchValue.startsWith("gAAAA")) {
      matchValue = await decrypt(matchValue, encKey);
    }

    rows.push([matchValue, p.status]);
  }

  return rows.map(r => r.join(",")).join("\n");
}

document.getElementById("sendBtn").addEventListener("click", async function () {
  const btn = this;

  if (!navigator.onLine) return;

  const errorBox = document.getElementById("sendError");
  errorBox.style.display = "none";

  // Save original HTML (SVG + ‚ÄúSend‚Äù)
  const originalHTML = btn.innerHTML;

  // Loading state
  btn.classList.add("btn-loading");
  btn.disabled = true;

  btn.innerHTML = `
    ${originalHTML}
    <div class="spinner" style="margin-left:6px;"></div>
  `;

  const payments = await loadPaymentsReadyCount();

  try {
    if (!payments.length) {
      errorBox.textContent = t.no_payments || "No payments to send.";
      errorBox.style.display = "block";
      btn.classList.remove("btn-loading");
      btn.disabled = false;
      btn.innerHTML = originalHTML;
      return;
    }

    const csvContent = await buildCsvFromPayments(payments);
    const blob = new Blob([csvContent], { type: "text/csv" });
    const formData = new FormData();
    formData.append("csv", blob, "payments.csv");

    const res = await fetch("/submit-payments", {
      method: "POST",
      body: formData
    });

    const text = await res.text();
    if (!res.ok) throw new Error(text || "Failed submitting payments");

    // SUCCESS ‚Üí update status = submitted
    const db = await openScandroidDB();
    const tx = db.transaction("payments", "readwrite");
    const store = tx.objectStore("payments");

    for (const p of payments) {
      if (p.status === "success") {
        p.status = "submitted";
        await store.put(p);
      }
    }

    // Update counters
    document.getElementById("paymentsReadyCount").textContent = "0";
    document.getElementById("peopleScannedCount").textContent = "0";
    document.getElementById("totalAmountText").textContent = "0";

    // Update last submission timestamp
    const now = new Date();
    const formatted = now.toLocaleString("en-GB", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });

    localStorage.setItem("scandroid_last_payment_submission", formatted);
    document.getElementById("lastSubmissionText").textContent = formatted;

  } catch (err) {
    console.error(err);
    errorBox.textContent =
      "‚ùå Failed to send payments ‚Äî records left unchanged for debugging.";
    errorBox.style.display = "block";
  }

  // Restore original button
  btn.classList.remove("btn-loading");
  btn.disabled = false;
  btn.innerHTML = originalHTML;
});


</script>
<script>
  window.addEventListener("DOMContentLoaded", () => {
    const savedDate = localStorage.getItem("scandroid_last_synced_date");
    const savedCount = localStorage.getItem("scandroid_last_synced_count");

    if (savedDate) {
      const el = document.getElementById("lastSyncedText");
      if (el) el.textContent = savedDate;
    }

    if (savedCount) {
      const el = document.getElementById("beneficiaryCount");
      if (el) el.textContent = savedCount;
    }
  });
</script>
</body>
</html>
