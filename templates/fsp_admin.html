<!DOCTYPE html>
<html lang="{{ lang }}" {% if lang == 'ar' %}dir="rtl"{% endif %}>
<head>
  <link rel="icon" type="image/x-icon" href="{{ url_for('static', filename='favicon.ico') }}">
  <meta charset="UTF-8">
  <title>FSP Admin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">


  <style>
      :root {
        --bg: #f3f4f6;
        --card: #ffffff;
        --ink: #111827;
        --muted: #6b7280;
        --line: #e5e7eb;
        --radius: 16px;
        --shadow-soft: 0 10px 30px rgba(0,0,0,0.06);
      }

      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        background-color: var(--bg);
        color: var(--ink);
        margin: 0;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }

      header {
        background-color: #002855;
        padding: 12px 24px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        color: white;
        position: relative;
        z-index: 3000;
      }

      .header-left {
        display: flex;
        align-items: center;
      }

      .header-left img {
        height: 32px;
        width: auto;
        object-fit: contain;
      }

      /* Title */
      .header-title {
        flex: 1;
        text-align: left;
        padding-left: 20px;
        font-size: 1.1rem;
        color: #ffffff;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .title-bold {
        font-weight: 800;
        letter-spacing: 0.3px;
      }

      .title-divider {
        opacity: 0.8;
      }

      .title-program {
        font-weight: 300;
        opacity: 0.95;
      }

      /* Account button */
      .account-icon-svg {
        width: 16px;
        height: 16px;
        filter: invert(100%);
      }

      .account-arrow-svg {
        width: 12px;
        height: 12px;
        filter: invert(100%);
        margin-left: 4px;
        transition: transform 0.15s ease;
      }

      .account-btn {
        background: transparent;
        border: none;
        color: #ffffff;
        padding: 6px 10px;
        border-radius: 18px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 6px;
        transition: border 0.2s ease;
      }

      .account-btn:hover {
        border: 1px solid rgba(255,255,255,0.9);
      }

      /* Rotate arrow when open */
      .account-btn.active .account-arrow-svg {
        transform: rotate(180deg);
      }

      /* Wrapper */
      .header-account-wrapper {
        display: flex;
        align-items: center;
        gap: 16px;
        position: relative;
      }

      .lang-select select {
        padding: 6px 10px;
        border-radius: 8px;
        border: 1px solid #d1d5db;
        background: #ffffff;
        font-weight: 600;
        cursor: pointer;
      }

      /* Dropdown */
      .account-menu {
        position: absolute;
        background: #ffffff;
        top: 48px;
        right: 0;
        min-width: 220px;
        border-radius: 8px;
        box-shadow: 0 4px 14px rgba(0,0,0,0.15);
        z-index: 3001;
        padding: 10px 0;
      }

      .hidden {
        display: none;
      }

      .account-menu-item {
        padding: 10px 16px;
        font-size: 14px;
        text-decoration: none;
        color: #000;
        display: block;
      }

      .account-menu-item:hover {
        background: #f2f2f2;
      }

      .account-menu-divider {
        border-top: 1px solid #e5e7eb;
        margin: 6px 0;
      }

      .user-info {
        font-size: 13px;
      }

      /* small status-pill kept from FSP UI */
      .status-pill {
        display:inline-flex;
        align-items:center;
        gap:6px;
        padding:4px 10px;
        border-radius:999px;
        font-size:12px;
        font-weight:700;
        border:1px solid transparent;
      }
      .status-pill.online {
        background:#e7f9ef; color:#0f5132; border-color:#b7ebcd;
      }
      .status-pill.offline {
        background:#fdecec; color:#842029; border-color:#f5c2c7;
      }

      main {
        flex-grow: 1;
        padding: 24px 16px 40px 16px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 24px;
      }

      .row-box{
        max-width: 720px;
        width: 100%;
        display:flex;
        align-items:center;
        gap:14px;
      }

      .info-box {
        flex: 1;
        background: #ffffff;
        border-radius: 12px;
        padding: 12px 16px;
        box-shadow: var(--shadow-soft);
        border: 1px solid var(--line);
        font-size: 0.95rem;

        /* subtle mobile-app card polish */
        backdrop-filter: blur(6px);
        -webkit-backdrop-filter: blur(6px);
        transition: box-shadow 0.2s ease;
      }

      /* nicer hover */
      .info-box:hover {
        box-shadow: 0 12px 28px rgba(0,0,0,0.10);
      }

      .info-title {
        font-weight: 700;
        color: var(--ink);
        margin-bottom: 4px;
      }

      .info-sub {
        color: var(--muted);
        font-size: 0.9rem;
      }

      #syncBtn, #scanBtn, #sendBtn {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 12px 20px;
        font-size: 1rem;
        font-weight: 700;
        border: none;
        border-radius: 14px;
        cursor: pointer;
        white-space: nowrap;
        box-shadow: var(--shadow-soft);

        /* premium tap animation */
        transition: transform 0.1s ease, box-shadow 0.2s ease;
      }

      /* active touch effect */
      #syncBtn:active,
      #scanBtn:active,
      #sendBtn:active {
        transform: scale(0.97);
        box-shadow: 0 4px 12px rgba(0,0,0,0.12);
      }

      #syncBtn {
        background-color: #1d4ed8;
        color: #fff;
      }
      #syncBtn:hover:not(:disabled) { background:#1e40af; transform:translateY(-1px); }

      #scanBtn {
        background-color:#16a34a;
        color:white;
      }
      #scanBtn:hover { background:#15803d; transform:translateY(-1px); }

      #sendBtn {
        background-color:#be185d;
        color:white;
      }
      #sendBtn:hover { background:#9d174d; transform:translateY(-1px); }

      footer{ display:flex; justify-content:space-between; align-items:center; padding:12px 18px; font-size:0.9rem; background:#002855; color:#fff; border-top:1px solid rgba(255,255,255,0.15) }

      #syncBtn img,
      #scanBtn img,
      #sendBtn img {
        height: 20px;
        filter: invert(1);
      }

      /* --- Spinner animation --- */
      .spinner {
        width: 18px;
        height: 18px;
        border: 3px solid rgba(255,255,255,0.6);
        border-top-color: white;
        border-radius: 50%;
        animation: spin 0.7s linear infinite;
      }

      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      /* Button loading state */
      .btn-loading {
        opacity: 0.8;
        pointer-events: none;
        transform: none !important;
      }

      .btn-loading img {
        opacity: 0.3;
      }

      @media (max-width:600px) {
        /* Stack header elements vertically and center them for better mobile layout */
        header {
          flex-direction: column;
          gap: 8px;
          padding: 12px;
          align-items: center;
        }

        .header-title {
          padding-left: 0;
          text-align: center;
        }

        .header-account-wrapper {
          flex-direction: column;
          gap: 8px;
          width: 100%;
          align-items: center;
        }

        .header-left img {
          height: 38px;
        }

        main {
          padding: 12px 12px 24px 12px;
          gap: 18px;
        }

        .row-box {
          flex-direction: column;
          align-items: stretch;
          max-width: 100%;
        }

        .info-box {
          padding: 14px 16px;
          border-radius: 18px;
          margin-bottom: 4px;
          text-align: center;
        }

        #syncBtn,
        #scanBtn,
        #sendBtn {
          width: 100%;
          justify-content: center;
          padding: 14px;
          font-size: 1.05rem;
          border-radius: 18px;
        }

        footer {
          flex-direction: column;
          text-align: center;
          gap: 4px;
          padding: 14px;
          font-size: 0.85rem;
        }

        .btn-disabled {
          opacity: 0.5;
          pointer-events: none;
          filter: grayscale(40%);
        }
      }
  </style>

</head>

<body>

<header>
  <div class="header-left">
    <img src="/instance-static/ns1.png" alt="">
  </div>

  <div class="header-title">
    <span class="title-bold">121 Scan</span>
    <span class="title-divider">|</span>
    <span class="title-program">{{ program_title }}</span>
  </div>

  <div class="header-account-wrapper">
    <form method="get" action="/fsp-admin" class="lang-select">
      <select name="lang" onchange="this.form.submit()">
        <option value="en" {% if lang == 'en' %}selected{% endif %}>English</option>
        <option value="fr" {% if lang == 'fr' %}selected{% endif %}>Fran√ßais</option>
        <option value="ar" {% if lang == 'ar' %}selected{% endif %}>ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</option>
      </select>
    </form>

    <span id="netStatus" class="status-pill offline">{{ t.offline or "Offline" }}</span>

    <div class="account-dropdown">
      <button class="account-btn" onclick="toggleAccountDropdown()" type="button">
        <img src="{{ url_for('static', filename='icons/user.svg') }}" class="account-icon-svg" alt="">
        Account
        <img src="{{ url_for('static', filename='icons/arrow.svg') }}" class="account-arrow-svg" alt="">
      </button>

      <div id="account-menu" class="account-menu hidden">
        <div class="account-menu-item user-info">
          <strong>Logged in as:</strong><br>
          {{ username }}
        </div>

        <div class="account-menu-divider"></div>

        <a href="/fsp-logout?lang={{ lang }}" class="account-menu-item">Logout</a>
      </div>
    </div>
  </div>
</header>

<main>

  <!-- SYNC BLOCK -->
  <div class="row-box">
    <div class="info-box">
      <div class="info-title">
        {{ t.beneficiaries_ready_to_scan or "Ready to scan:" }}
        <span id="beneficiaryCount">0</span>
      </div>
      <div class="info-sub">
        {{ t.last_synced or "Last synced:" }}
        <span id="lastSyncedText">Not synced yet</span>
      </div>
    </div>

    <button id="syncBtn">
      <img src="{{ url_for('static', filename='icons/sync.svg') }}" alt="" style="height:20px;">
      Sync
    </button>
  </div>

  <!-- SCAN BLOCK -->
  <div class="row-box">
    <div class="info-box">
      <div class="info-title">
        {{ t.people_scanned or "People scanned:" }}
        <span id="peopleScannedCount">0</span>
      </div>
      <div class="info-sub">
        {{ t.total_amount or "Total amount:" }}
        <span id="totalAmountText">‚Äî</span>
      </div>
    </div>

    <button id="scanBtn" onclick="location.href='/scan?lang={{ lang }}'">
      <img src="{{ url_for('static', filename='icons/scan.svg') }}" alt="" style="height:20px;">
      Scan
    </button>
  </div>

  <!-- SEND BLOCK -->
  <div class="row-box">
    <div class="info-box">
      <div class="info-title">
        {{ t.payments_ready_send or "Payments ready to send:" }}
        <span id="paymentsReadyCount">0</span>
      </div>

      <div class="info-sub">
        {{ t.last_payments_submit or "Last submission:" }}
        <span id="lastSubmissionText">‚Äî</span>
      </div>

      <div id="sendError" class="error-box" style="display:none;"></div>
    </div>

    <button id="sendBtn">
      <img src="{{ url_for('static', filename='icons/send.svg') }}" alt="" style="height:20px;">
      Send
    </button>
  </div>

</main>

<footer>
  <div class="footer-left">{{ t.footer_dev }}</div>
  <div class="footer-right">{{ t.footer_support }}</div>
</footer>

<script>
function toggleAccountDropdown() {
  const menu = document.getElementById('account-menu');
  const btn = document.querySelector('.account-btn');

  menu.classList.toggle('hidden');
  btn.classList.toggle('active');
}

document.addEventListener('click', function(e) {
  const menu = document.getElementById('account-menu');
  const btn = document.querySelector('.account-btn');

  if (!btn.contains(e.target)) {
    menu.classList.add('hidden');
    btn.classList.remove('active');
  }
});
</script>

<script>
  // JINJA TEMPLATE VARIABLE
  const t = {{ t | tojson | safe }};
</script>

<script>
  const PROGRAM_CURRENCY = "{{ config.get('programCurrency', '') }}";
</script>


<!-- IndexedDB helper -->
<script src="https://cdn.jsdelivr.net/npm/idb@7/build/umd.js"></script>
<!-- ZIP helper -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script>
  const COLUMN_TO_MATCH = "{{ COLUMN_TO_MATCH }}";
</script>

<script>
  const ONLINE_TEXT = "{{ t.online or 'Online' }}";
  const OFFLINE_TEXT = "{{ t.offline or 'Offline' }}";

  // -----------------------------
  // UPDATED SYNC BUTTON HANDLER
  // -----------------------------
  document.getElementById("syncBtn").addEventListener("click", async function () {
    if (!navigator.onLine) return;

    const btn = this;
    const statusDiv = document.getElementById("statusMessage");

    // Store original button content (SVG + text)
    const originalHTML = btn.innerHTML;

    // Visual loading state
    btn.classList.add("btn-loading");
    btn.disabled = true;

    btn.innerHTML = `
      ${originalHTML}
      <div class="spinner" style="margin-left:6px;"></div>
    `;

    try {
      const syncRes = await fetch("/sync-fsp?lang={{ lang }}");
      const syncJson = await syncRes.json();
      const syncMessage = syncJson.message || "Synced";

      statusDiv && (statusDiv.textContent = syncMessage + " ‚Üí Importing‚Ä¶");

      const importResult = await importLatestCache(true);

      const finalMessage =
        `Sync complete: ${syncMessage} ‚Üí Imported ${importResult.written} beneficiaries and ${importResult.photosWritten} photos.`;

      statusDiv && (statusDiv.textContent = "‚úÖ " + finalMessage);

      // Timestamp
      const now = new Date();
      const formatted = now.toLocaleString("en-GB", {
        day: "2-digit",
        month: "2-digit",
        year: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });

      const lastSyncedEl = document.getElementById("lastSyncedText");
      const readyCountEl = document.getElementById("beneficiaryCount");

      if (lastSyncedEl) lastSyncedEl.textContent = formatted;
      if (readyCountEl) readyCountEl.textContent = importResult.written;

      localStorage.setItem("scandroid_last_synced_date", formatted);
      localStorage.setItem("scandroid_last_synced_count", importResult.written);

    } catch (err) {
      console.error(err);
      statusDiv && (statusDiv.textContent = "‚ùå Failed to sync & import. Please try again.");
    }

    // Restore original button content
    btn.innerHTML = originalHTML;
    btn.classList.remove("btn-loading");
    btn.disabled = false;
  });

  // Service worker
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/service-worker.js?v=2', { updateViaCache: 'none' }).catch(()=>{});
    });
  }

  // Online detection -> update status pill
  const pill = document.getElementById('netStatus');
  function setOnlineState(isOnline) {
      pill.textContent = isOnline ? ONLINE_TEXT : OFFLINE_TEXT;
      pill.classList.toggle('online', isOnline);
      pill.classList.toggle('offline', !isOnline);

      // Disable/enable buttons based on connectivity
      updateOnlineButtonState(isOnline);
  }


  async function pingWithTimeout() {
    try {
      const res = await fetch('/ping', { cache: 'no-store' });
      return res.ok;
    } catch {
      return false;
    }
  }


  let consecutivePingFailures = 0;

  async function checkOnline() {
    const ok = await pingWithTimeout();

    if (ok) {
      consecutivePingFailures = 0;
      setOnlineState(true);
    } else {
      consecutivePingFailures++;
      if (consecutivePingFailures >= 3) {
        setOnlineState(false);
      }
    }
  }


  checkOnline();
  setInterval(checkOnline, 60000);
  window.addEventListener('online', () => setOnlineState(true));
  window.addEventListener('offline', () => setOnlineState(false));
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistration().then(reg => reg && reg.update());
  }
</script>

<script>
  // ---------- IndexedDB ----------
  async function openScandroidDB() {
    return await idb.openDB('scandroid', 13, {
      upgrade(db) {
        if (!db.objectStoreNames.contains('records')) db.createObjectStore('records', { keyPath: 'uuid' });
        if (!db.objectStoreNames.contains('photos'))  db.createObjectStore('photos',  { keyPath: 'uuid' });
        if (!db.objectStoreNames.contains('meta'))    db.createObjectStore('meta',    { keyPath: 'key' });
        if (!db.objectStoreNames.contains('decisions')) db.createObjectStore('decisions', { keyPath: 'uuid' });
        if (!db.objectStoreNames.contains('transaction')) db.createObjectStore('transaction', { keyPath: 'uuid' });
        if (!db.objectStoreNames.contains('payments')) db.createObjectStore('payments', { keyPath: 'uuid' });
      }
    });
  }

  const chunk = (arr, size) =>
    Array.from({ length: Math.ceil(arr.length / size) }, (_, i) => arr.slice(i * size, i * size + size
)) ;

  const findJsonEntry = (zip) =>
    Object.values(zip.files).find(f => /registrations_cache\.json$/i.test(f.name)) || null;

  const listPhotoEntries = (zip) =>
    Object.values(zip.files).filter(f => /\.enc$/i.test(f.name));

  // -----------------------------------------------------
  // UPDATED importLatestCache() SUPPORTS SILENT MODE + RETURNS COUNTS
  // -----------------------------------------------------
  async function importLatestCache(silent = false) {
    if (!navigator.onLine) {
      if (!silent) showOfflineWarningTemporarily();
      return { written: 0, photosWritten: 0 };
    }

    const statusDiv = document.getElementById('statusMessage');

    try {
      const res = await fetch('/api/offline/latest.zip', { cache: 'no-store' });
      if (!res.ok) throw new Error(`Fetch latest.zip failed: ${res.status}`);
      const zipBlob = await res.blob();
      const zip = await JSZip.loadAsync(zipBlob);

      const jsonEntry = findJsonEntry(zip);
      if (!jsonEntry) throw new Error('registrations_cache.json not found in ZIP');
      const jsonText = await jsonEntry.async('string');
      const records = JSON.parse(jsonText) || [];

      const db = await openScandroidDB();

      // Import records
      let written = 0;
      for (const group of chunk(records, 50)) {
        await Promise.all(group.map(async rec => {
          const uuid = rec.uuid || rec._uuid;
          if (!uuid) return;
          await db.put('records', rec);
          written++;
        }));
      }

      // Import photos
      const photos = listPhotoEntries(zip);
      let photosWritten = 0;
      for (const group of chunk(photos, 10)) {
        const items = await Promise.all(group.map(async entry => {
          const m = entry.name.match(/([^/\\]+)\.enc$/i);
          const uuid = m ? m[1] : null;
          if (!uuid) return null;
          const buf = await entry.async('arraybuffer');
          return { uuid, bytes: new Uint8Array(buf) };
        }));
        await Promise.all(items.filter(Boolean).map(item => db.put('photos', item)));
        photosWritten += items.filter(Boolean).length;
      }

      // ---- NEW: import transactions.json ----
      const txEntry = Object.values(zip.files).find(f => /transactions\.json$/i.test(f.name));
      if (txEntry) {
        const txText = await txEntry.async("string");
        const txList = JSON.parse(txText) || [];

        for (const t of txList) {
          const uuid = t.registrationReferenceId || t.uuid;
          if (!uuid) continue;

          await db.put("transaction", {
            uuid: uuid,
            amount: t.amount || 0,
            paymentId: t.paymentId
          });
        }
      }

      if (!silent) {
        statusDiv.textContent =
          `‚úÖ ${written} beneficiaries ¬∑ ${photosWritten} photos imported.`;
      }

      await db.put('meta', {
        key: 'batchInfo',
        value: { importedAt: Date.now(), recordCount: written, photos: photosWritten }
      });

      // RETURN COUNTS
      return { written, photosWritten };

    } catch (err) {
      console.error(err);
      if (!silent) {
        statusDiv.textContent = `‚ùå Import failed: ${err.message || err}`;
      }
      return { written: 0, photosWritten: 0 };
    }
  }
</script>

<script>

  const generateCsvBtn = document.getElementById('generateCsvBtn');
  const submitCsvBtn = document.getElementById('submitCsvBtn');
  const csvCountEl = document.getElementById('csv-count');
  const submitStatus = document.getElementById('submit-status');
  let cachedCsvBlob = null;

  async function loadPaymentsAndCount() {
    const db = await openScandroidDB();
    if (!db.objectStoreNames.contains('payments')) return 0;

    const tx = db.transaction('payments', 'readonly');
    const store = tx.objectStore('payments');
    const allPayments = await store.getAll();
    csvCountEl.textContent = allPayments.length;
    return allPayments;
  }

  // Decrypt helper
  async function decrypt(encrypted, keyHex) {
    try {
      const key = await crypto.subtle.importKey(
        "raw",
        hexToBytes(keyHex),
        "AES-GCM",
        false,
        ["decrypt"]
      );

      const data = atob(encrypted);
      const iv = Uint8Array.from(data.slice(0, 12), c => c.charCodeAt(0));
      const ciphertext = Uint8Array.from(data.slice(12), c => c.charCodeAt(0));
      const decrypted = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ciphertext);
      return new TextDecoder().decode(decrypted);
    } catch (err) {
      console.error("Decryption failed:", err);
      return encrypted;
    }
  }

  function hexToBytes(hex) {
    return new Uint8Array(hex.match(/.{1,2}/g).map(b => parseInt(b, 16)));
  }

  generateCsvBtn.addEventListener('click', async () => {
    generateCsvBtn.disabled = true;
    submitStatus.textContent = "‚è≥ Generating CSV...";

    const db = await openScandroidDB();
    const payments = await loadPaymentsAndCount();

    if (!payments.length) {
      submitStatus.textContent = "‚ö†Ô∏è No payments to export.";
      generateCsvBtn.disabled = false;
      return;
    }

    const metaTx = db.transaction('meta', 'readonly');
    const metaStore = metaTx.objectStore('meta');
    const encKeyObj = await metaStore.get('encryptionKey');
    const encKey = encKeyObj?.value || '';

    const csvRows = [['phoneNumber', 'status']];
    for (const p of payments) {
      let phone = p.match_value;
      if (encKey && phone && phone.startsWith('gAAAA')) {
        phone = await decrypt(phone, encKey);
      }
      csvRows.push([phone, p.status]);
    }

    const csvContent = csvRows.map(row => row.join(',')).join('\n');
    cachedCsvBlob = new Blob([csvContent], { type: 'text/csv' });

    submitStatus.textContent = "‚úÖ CSV ready with " + (csvRows.length - 1) + " records.";
    submitCsvBtn.disabled = false;
  });

  submitCsvBtn.addEventListener('click', async () => {
    if (!navigator.onLine) {
      return;
    }
    if (!cachedCsvBlob) {
      alert("No CSV generated yet.");
      return;
    }

    const formData = new FormData();
    formData.append('csv', cachedCsvBlob, 'payments.csv');

    submitStatus.textContent = "üì§ Sending...";
    try {
      const res = await fetch('/submit-payments', {
        method: 'POST',
        body: formData
      });

      const responseText = await res.text();
      if (!res.ok) throw new Error(responseText || "Unknown error from server");

      submitStatus.textContent =
        t.payment_submit_success || "‚úÖ Payments submitted successfully!";

      const db = await openScandroidDB();
      const tx = db.transaction('payments', 'readwrite');
      await tx.objectStore('payments').clear();

      csvCountEl.textContent = "0";
      submitCsvBtn.disabled = true;
      generateCsvBtn.disabled = false;
      cachedCsvBlob = null;
    } catch (err) {
      console.error(err);
      submitStatus.textContent =
        (t.payment_submit_failed || "‚ùå Failed to submit") + ": " + (err.message || "Unknown error");
    }
  });

  // Init on page load
  loadPaymentsAndCount();

  let popupTimeout;
  function closeOfflinePopup() {
    const popup = document.getElementById('offline-popup');
    popup.style.display = 'none';
    clearTimeout(popupTimeout);
  }

  // Load last synced time from localStorage on page load
  // Load "Last synced" summary on page load


</script>

<script>
  async function loadPeopleScannedCount() {
    try {
      const db = await openScandroidDB();

      if (!db.objectStoreNames.contains("payments")) {
        document.getElementById("peopleScannedCount").textContent = "0";
        return;
      }

      const tx = db.transaction("payments", "readonly");
      const store = tx.objectStore("payments");
      const all = await store.getAll();

      // Count ONLY pending, not submitted
      const count = all.filter(p => p.status === "success").length;

      document.getElementById("peopleScannedCount").textContent = count;

    } catch (err) {
      console.error("peopleScannedCount error:", err);
      document.getElementById("peopleScannedCount").textContent = "0";
    }
  }


  // ‚úÖ RUN ON PAGE LOAD
  window.addEventListener("DOMContentLoaded", loadPeopleScannedCount);
</script>

<script>
async function loadTotalAmount() {
  try {
    const db = await openScandroidDB();

    if (!db.objectStoreNames.contains("transaction") ||
        !db.objectStoreNames.contains("payments")) {
      document.getElementById("totalAmountText").textContent = "0";
      return;
    }

    // 1. Load only "success" (pending) scanned beneficiaries
    const payTx = db.transaction("payments", "readonly");
    const payStore = payTx.objectStore("payments");
    const allPayments = await payStore.getAll();
    const pending = allPayments.filter(p => p.status === "success");

    const scannedSet = new Set(pending.map(x => x.uuid));

    // 2. Load all transactions
    const tx = db.transaction("transaction", "readonly");
    const store = tx.objectStore("transaction");
    const transactions = await store.getAll();

    // 3. Sum ONLY amounts of beneficiaries that are still pending
    let total = 0;
    for (const t of transactions) {
      if (scannedSet.has(t.uuid)) {
        total += t.amount || 0;
      }
    }

    document.getElementById("totalAmountText").textContent =
      PROGRAM_CURRENCY
        ? total.toLocaleString() + " " + PROGRAM_CURRENCY
        : total.toLocaleString();

  } catch (e) {
    console.error("Total amount calc error:", e);
    document.getElementById("totalAmountText").textContent = "0";
  }
}

window.addEventListener("DOMContentLoaded", loadTotalAmount);

</script>
<script>
async function loadPaymentsReadyCount() {
  try {
    const db = await openScandroidDB();

    if (!db.objectStoreNames.contains("payments")) {
      document.getElementById("paymentsReadyCount").textContent = "0";
      return [];
    }

    const tx = db.transaction("payments", "readonly");
    const store = tx.objectStore("payments");
    const all = await store.getAll();

    // Only count pending ones: status === "success"
    const pending = all.filter(p => p.status === "success");

    document.getElementById("paymentsReadyCount").textContent = pending.length;
    return pending;
  } catch (err) {
    console.error("paymentsReadyCount error:", err);
    document.getElementById("paymentsReadyCount").textContent = "0";
    return [];
  }
}
</script>
<!-- *** NEW SEND LOGIC ‚Äì Added NON-DESTRUCTIVELY *** -->
<script>
async function loadPaymentsReadyCount() {
  const db = await openScandroidDB();
  if (!db.objectStoreNames.contains("payments")) {
    document.getElementById("paymentsReadyCount").textContent = "0";
    return [];
  }
  const tx = db.transaction("payments", "readonly");
  const store = tx.objectStore("payments");
  const all = await store.getAll();
  const pending = all.filter(p => p.status === "success");

  document.getElementById("paymentsReadyCount").textContent = pending.length;
  return pending;

}

function loadLastSubmission() {
  const saved = localStorage.getItem("scandroid_last_payment_submission");
  if (saved) document.getElementById("lastSubmissionText").textContent = saved;
}

async function buildCsvFromPayments(payments) {
  const db = await openScandroidDB();
  const metaTx = db.transaction("meta", "readonly");
  const metaStore = metaTx.objectStore("meta");
  const encKeyObj = await metaStore.get("encryptionKey");
  const encKey = encKeyObj?.value || "";

  // üî• Use the correct match column name from config
  const rows = [[COLUMN_TO_MATCH, "status"]];

  for (const p of payments) {
    let matchValue = p.match_value;

    if (encKey && matchValue && matchValue.startsWith("gAAAA")) {
      matchValue = await decrypt(matchValue, encKey);
    }

    rows.push([matchValue, p.status]);
  }

  return rows.map(r => r.join(",")).join("\n");
}

document.getElementById("sendBtn").addEventListener("click", async function () {
  const btn = this;

  if (!navigator.onLine) return;

  const errorBox = document.getElementById("sendError");
  errorBox.style.display = "none";

  // Save original HTML (SVG + ‚ÄúSend‚Äù)
  const originalHTML = btn.innerHTML;

  // Loading state
  btn.classList.add("btn-loading");
  btn.disabled = true;

  btn.innerHTML = `
    ${originalHTML}
    <div class="spinner" style="margin-left:6px;"></div>
  `;

  const payments = await loadPaymentsReadyCount();

  try {
    if (!payments.length) {
      errorBox.textContent = t.no_payments || "No payments to send.";
      errorBox.style.display = "block";
      btn.classList.remove("btn-loading");
      btn.disabled = false;
      btn.innerHTML = originalHTML;
      return;
    }

    const csvContent = await buildCsvFromPayments(payments);
    const blob = new Blob([csvContent], { type: "text/csv" });
    const formData = new FormData();
    formData.append("csv", blob, "payments.csv");

    const res = await fetch("/submit-payments", {
      method: "POST",
      body: formData
    });

    const text = await res.text();
    if (!res.ok) throw new Error(text || "Failed submitting payments");

    // SUCCESS ‚Üí update status = submitted
    const db = await openScandroidDB();
    const tx = db.transaction("payments", "readwrite");
    const store = tx.objectStore("payments");

    for (const p of payments) {
      if (p.status === "success") {
        p.status = "submitted";
        await store.put(p);
      }
    }

    // Update counters
    document.getElementById("paymentsReadyCount").textContent = "0";
    document.getElementById("peopleScannedCount").textContent = "0";
    document.getElementById("totalAmountText").textContent = "0";

    // Update last submission timestamp
    const now = new Date();
    const formatted = now.toLocaleString("en-GB", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });

    localStorage.setItem("scandroid_last_payment_submission", formatted);
    document.getElementById("lastSubmissionText").textContent = formatted;

  } catch (err) {
    console.error(err);
    errorBox.textContent =
      "‚ùå Failed to send payments ‚Äî records left unchanged for debugging.";
    errorBox.style.display = "block";
  }

  // Restore original button
  btn.classList.remove("btn-loading");
  btn.disabled = false;
  btn.innerHTML = originalHTML;
});


</script>
<script>
  window.addEventListener("DOMContentLoaded", () => {
    const savedDate = localStorage.getItem("scandroid_last_synced_date");
    const savedCount = localStorage.getItem("scandroid_last_synced_count");

    if (savedDate) {
      const el = document.getElementById("lastSyncedText");
      if (el) el.textContent = savedDate;
    }

    if (savedCount) {
      const el = document.getElementById("beneficiaryCount");
      if (el) el.textContent = savedCount;
    }
  });
</script>
<script>
window.addEventListener("DOMContentLoaded", () => {
  // Restore payments ready count
  loadPaymentsReadyCount().catch(console.error);

  // Restore last payment submission
  const savedSubmission = localStorage.getItem("scandroid_last_payment_submission");
  if (savedSubmission) {
    const el = document.getElementById("lastSubmissionText");
    if (el) el.textContent = savedSubmission;
  }
});
</script>
<script>
function updateOnlineButtonState(isOnline) {
    const syncBtn = document.getElementById("syncBtn");
    const sendBtn = document.getElementById("sendBtn");

    if (isOnline) {
        syncBtn.disabled = false;
        sendBtn.disabled = false;
        syncBtn.classList.remove("btn-disabled");
        sendBtn.classList.remove("btn-disabled");
    } else {
        syncBtn.disabled = true;
        sendBtn.disabled = true;
        syncBtn.classList.add("btn-disabled");
        sendBtn.classList.add("btn-disabled");
    }
}
</script>

</body>
</html>